<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://windherd.github.io/</id>
    <title>风中追风</title>
    <updated>2019-06-18T09:28:36.037Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://windherd.github.io/"/>
    <link rel="self" href="https://windherd.github.io//atom.xml"/>
    <subtitle>Maintain curiosity, to maintain pure heart.</subtitle>
    <logo>https://windherd.github.io//images/avatar.png</logo>
    <icon>https://windherd.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 风中追风</rights>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://windherd.github.io//post/about</id>
        <link href="https://windherd.github.io//post/about">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<p>阳光沙滩仙人掌, 还有我的素梅酱</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[广告名词解释]]></title>
        <id>https://windherd.github.io//post/广告名词解释</id>
        <link href="https://windherd.github.io//post/广告名词解释">
        </link>
        <updated>2018-11-13T04:25:44.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="1-基本名词"><strong>1. 基本名词</strong></h3>
<p><strong>CTR（Click Through Rate）</strong>：点击率，衡量线上广告效果的重要因素，等于广告点击数量与广告展现数量的比率，CTR越高，即点击广告的比率越高，广告效果越好。</p>
<p><strong>CVR（Conversation Rate）</strong>：转化率，等于转化次数与到达次数的比率。这里的到达指用户点击进入广告主页面；转化指广告主所期望用户最终实现的行为，如购买、拨打电话等。转化率是效果广告最重要的指标之一。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="1-基本名词"><strong>1. 基本名词</strong></h3>
<p><strong>CTR（Click Through Rate）</strong>：点击率，衡量线上广告效果的重要因素，等于广告点击数量与广告展现数量的比率，CTR越高，即点击广告的比率越高，广告效果越好。</p>
<p><strong>CVR（Conversation Rate）</strong>：转化率，等于转化次数与到达次数的比率。这里的到达指用户点击进入广告主页面；转化指广告主所期望用户最终实现的行为，如购买、拨打电话等。转化率是效果广告最重要的指标之一。</p>
<!--more-->
<p><strong>DSP（Demand-side Platform）</strong>：购买广告的产品形态，为需求方（即广告主或代理商）提供实时竞价投放平台， 需求方可以在平台上管理广告活动及投放策略， 包括设置目标受众的定向条件、预算、出价、创意等，帮助广告主在互联网或者移动互联网上进行广告投放。</p>
<p><strong>DSPAN（DSP+Ad Network）</strong>：扩展型DSP。DSP+网络媒体的混合体，将成熟的DSP模式与Ad Network模式相结合，不仅支持RTB实时竞价，同时支持PMP私有交易，为广告主提供了更完善的程序化广告解决方案。</p>
<p><strong>DMP（Data Management Platform）</strong>：数据管理平台。专门进行广告数据收集与加工的平台，可以为广告主提供多元化的数据管理服务。</p>
<p><strong>SSP（Supply Side Platform）</strong>：供给方平台。程序化广告的广告主资源管理系统平台以及相应的服务提供方。</p>
<p><strong>SEM（Search Engine Marketing）</strong>：搜索引擎营销。搜索广告对应的需求方产品，通过竞价采买搜索引擎关键词来做推广，可以指代涉及使用搜索引擎的付费数字营销。</p>
<p><strong>RTB（Real Time Bidding 实时竞价） :</strong> 是 DSP、广告交易平台等在网络广告投放中采用的主要售卖方式，在极短的时间内通过对目标受众竞价的方式获得该次广告展现。仅限于购买广告交易资源， 无论在 PC 端或是移动端均可以实现 RTB 的购买方式。</p>
<p>**PDB（Programmatic Direct Buying 或 Premium Direct Buying）：**程序化直接采购，是把广告主常规购买的保量的优质媒体资源，利用程序化购买的方式进行人群定向等多维度定向的广告投放。把广告主常规按天购买的高端优质黄金媒体资源，利用程序化购买的方式进行人群定向等多维度定向的广告投放。每次展示什么广告，都由PDB系统对人群的辨识和算法决定。无论 RTB 或 PDB 模式都需要 DSP 的系统作为实现投放的桥梁。</p>
<p><strong>PD（ Preferred Deals）：</strong> 优先交易，与 PDB 的区别在于广告资源具有一定的不确定性， 广告位的展示量，不能预先保证。一种实时的交易，但媒体与买方事先进行过价格方面的约定。对于媒体而言，使用固定价格售卖的资源通常价格比使用竞价方式售卖更高。</p>
<p>**PA（ Private Auction）：**私有竞价，媒体把较受广告主们欢迎的广告位置专门拿出来，放到一个半公开的市场中进行售卖，供有实力的广告主们竞价，价高者得。广告交易平台（ Ad Exchange）：一个开放的、能够将媒体和广告主/广告代理商联系在一起的在线广告市场（类似于股票交易所）。邀请一些有实力的广告主在半公开市场以竞价的方式竞争广告位， 受邀竞价的方式与公开竞价基本相同，区别在于媒体可以邀请一些特定的买方对这部分的资源进行竞价。在受邀竞价的环境中，媒体可以给予不同的买方特定的权益，如提供给不同买方不同开放程度的数据等等。 PDB 私有程序化购买、 PD 优先交易、PA 私有竞价， 区别在于是否竞价以及广告位是否预留。</p>
<p><strong>PGB（Programmatic Guaranteed Buying）</strong>：程序化保量采购，即预留购买。</p>
<p><strong>Viewable Impression</strong> ：可见曝光。在线广告的一个度量，它表示一个展示广告在发布后是否被看到，且时间持续至少1秒。</p>
<p><strong>Feeds</strong> ：信息流。指出现在社交媒体平台用户好友动态中的广告，主要是夹杂在用户想要阅读的信息之中，常见的有文字、图片加链接形式，现也有以视频流的形式播放出现。</p>
<p><strong>Media Mix</strong> ：媒介组合。在同一媒体计划中，使用两种及两种以上不同的媒介，其总和效果远大于各媒体分别相加之和。</p>
<p>**DPA（Dynamic Product Ads）：**即是动态广告顾名思义，动态产品广告是一种会随着网页内容、用户行动而「动」的广告型态。这种广告非常适合拥有大量产品，且想要为潜在客户或既有客户建立个人化广告的企业，尤其适合电子商务。因为使用动态产品广告后，成效优化师不需要为大量商品分别建立广告，也不需要在产品资讯有变动时，一直去更新广告内容。</p>
<h3 id="2-广告投放名词"><strong>2. 广告投放名词</strong></h3>
<p><strong>CPC（Cost Per Click）</strong>：按点击结算，即网络广告每次点击的费用。在这种结算方式中，点击率的估计由供给方完成，点击的价值估计由需求方完成，通过点击出价的方式向市场通知自己的估价，这种分工对于网络广告清晰且合理，是效果广告常见的付费模式。</p>
<p><strong>CPM（Cost Per Mile）</strong>：按照千次展示结算。即供给方和需求方约定好每千次展示的计费标准，而这些展示能够带来多少收益由需求方承担风险。由于品牌广告是长期的利益，短期内无法衡量效果，所以通常采用这种计费方式。例如千次费用为10/cpm，即每一千人看到你的广告页面，你需要支付10单位货币的价格。</p>
<p><strong>CPS（Cost Per Sale）</strong>：按照销售订单数结算。这是一种最直观的按照转化付费的一种方式。需求方只需按照最后的转化收益来结算，从而最大程度的规避了风险。主要适用于一些垂直广告网络。</p>
<p><strong>CPA（Cost Per Action）</strong>：按照转化行为结算。同样是按照转化行为付费的一种结算方式，而action则可以包括下载、拨打电话等广告主所期望用户达到的行为。同样适用于垂直广告网络。</p>
<p><strong>CPT（Cost Per Time）</strong>：按照展示时间结算。一般是针对大品牌广告主特定的广告活动，将某个广告位以独占式的方式为广告主展示广告，并且按照展示的时间计费。这种计费方式适用于强曝光性/有一定定制性的广告位。</p>
<p><strong>eCPM（Effective Cost Per Mille）</strong>：一般指估计的千次展示收益，它由发生在媒体上的行为和广告主网站上的行为共同决定，是最关键的定量评估收益的指标。</p>
<p><strong>OCPC</strong> ：目标转化出价。典型的场景为今日头条广告。OCPC就是CPC和CPA的折中模式，其以转化为目标（CPA），但仍然以点击作为计费标准（CPC），针对所有广告主开放。</p>
<p><strong>OCPM（Optimized CostPer 1000 Impressions）</strong>：按优化目标出价。Facebook的主要出价方式，能够针对广告的成本目标和实时投放效果，进行快速地计算和调整，给出一个相对最优的出价。</p>
<p><strong>ROI（Return On Investment）</strong>：投入产出比。即指某次广告活动的总产出与总投入的比值，市平定效果广告营销的关键指标。例如花了1千元做推广，卖了5千元的货，则ROI被判定为5。</p>
<p><strong>DCO（Dynamic CreativeOptimization）</strong>：动态创意优化。指根据用户的标签属性匹配相应的创意，并根据他们的行为实时调整策略，自动选择最优方案。</p>
<h3 id="3-后台逻辑名词"><strong>3. 后台逻辑名词</strong></h3>
<p><strong>第二高价</strong> ：指在只有一个位置的拍卖中，向赢得该位置的广告主收取其下一位广告主的出价，也叫作vickrey拍卖。可以直观的理解为，所有实际收取的广告费用均低于广告主拍得该广告位的额拍卖价。</p>
<p><strong>MRP（Market Reserveprice）</strong>：市场保留价。为控制广告主质量和出售单价而设置的最低拍卖价格，可以理解为竞价广告中的“起价”或“底价”。</p>
<p><strong>BCPC（Bid CPC）</strong>：每次点击费用出价，即按照点击结算的出价价格。</p>
<p><strong>pCTR</strong> ：根据历史投放点击率估算的一次有效点击所需要的成本。</p>
<p><strong>Click Value</strong> ：点击价值，即单次点击为广告产品带来的收益。</p>
<h3 id="4-投放方法名词"><strong>4. 投放方法名词</strong></h3>
<p><strong>Retargeting</strong> ：重定向。即找出曾经对广告主的产品或服务产生兴趣的人，重新向他们投放该广告主的广告，被公认为精准程度最高、效果最突出的定向方式。</p>
<p><strong>Geo-retargeting</strong> ：地域定向。即通过地域划分的方式向特定区域的用户投放广告。</p>
<p><strong>频控</strong> ：频次控制，即限制某个用户在某一时间段内看到该广告的次数，有效控制信息流失率。一般来说，用户看到同一广告创意的次数上升，点击率随之下降，所以根据频次控制用户触及广告创意便十分重要。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AndroidStudio使用问题]]></title>
        <id>https://windherd.github.io//post/Androidstudio遇到的问题</id>
        <link href="https://windherd.github.io//post/Androidstudio遇到的问题">
        </link>
        <updated>2018-07-18T02:25:44.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>不能构造apk</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>不能构造apk</li>
</ul>
<!-- more -->
<blockquote>
<ol>
<li>File -&gt; Invalidate Caches -&gt; Invalidate.</li>
<li>File -&gt; Close Project.</li>
<li>Remove the project from the AS project selector window.</li>
<li>Quit from Android Studio</li>
<li>Start AS and open project again</li>
</ol>
</blockquote>
<ul>
<li>
<p>R文件爆红.</p>
<ol>
<li>
<p>检查布局文件是否有报错</p>
</li>
<li>
<p>如果你的项目比较大</p>
<pre><code>1. Help -&gt; Edit Custome Properties

2. idea.max.intellisense.filesize=99999

</code></pre>
</li>
</ol>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[10分钟系列之css]]></title>
        <id>https://windherd.github.io//post/10分钟系列之css</id>
        <link href="https://windherd.github.io//post/10分钟系列之css">
        </link>
        <updated>2018-07-13T02:25:44.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="一-css简介">一. CSS简介</h1>
<ul>
<li>CSS 指层叠样式表 (Cascading Style Sheets)</li>
<li>样式定义如何显示 HTML 元素,更好的修饰html</li>
<li>多种样式共同作用于一个标签</li>
<li>了解决内容与表现分离的问题</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1 id="一-css简介">一. CSS简介</h1>
<ul>
<li>CSS 指层叠样式表 (Cascading Style Sheets)</li>
<li>样式定义如何显示 HTML 元素,更好的修饰html</li>
<li>多种样式共同作用于一个标签</li>
<li>了解决内容与表现分离的问题</li>
</ul>
<!--more-->
<h1 id="二-css基础语法">二. CSS基础语法</h1>
<pre><code class="language-css">选择器名称 {属性名1:属性值1; 属性名2:属性值2;... }
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/3169108-8a7b74767c849112.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/349" alt=""></p>
<ul>
<li>
<p>如果值为若干单词，则要给值加引号：</p>
<p><code>p {font-family: &quot;sans serif&quot;;}</code></p>
</li>
</ul>
<h1 id="三css选择器">三.CSS选择器</h1>
<ul>
<li>
<p>选择器的分类</p>
<ul>
<li>类选择器
<ul>
<li><code>.类名{ color:red;...}</code></li>
</ul>
</li>
<li>id选择器
<ul>
<li><code>#id名{color:red;...}</code></li>
</ul>
</li>
<li>元素选择器
<ul>
<li><code>标签名{color:red;...}</code></li>
</ul>
</li>
<li>伪元素选择器
<ul>
<li><code>标签名:link{ color:red;...}</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>选择器 组合</p>
<pre><code class="language-css">h1,h2,h3,h4,h5,h6 {
  color: green;
  }
</code></pre>
</li>
<li>
<p>选择器 关系</p>
<p>{</p>
<pre><code class="language-css">li strong {
    font-style: italic;
    font-weight: normal;
  }
&lt;p&gt;&lt;strong&gt;我是粗体字，不是斜体字，因为我不在列表当中，所以这个规则对我不起作用&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;我是斜体字。这是因为 strong 元素位于 li 元素内。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;我是正常的字体。&lt;/li&gt;
&lt;/ol&gt; 
</code></pre>
<p>}</p>
<h1 id="四csss与html的结合方式">四.CSSS与HTML的结合方式</h1>
<ol>
<li>内部样式
<ol>
<li>style属性方式<code>&lt;font style=&quot;font-size:150;color:red&quot;&gt;爱好&lt;/font&gt;</code></li>
<li>style标签方式<code>&lt;style&gt;&lt;/style&gt;</code> 放在head标签中</li>
</ol>
</li>
<li>外部样式
<ol>
<li>导入方式<code>@import url=(&quot;xxx.css&quot;)</code></li>
<li>链接方式<code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;xxx.css&quot;&gt;&lt;/link&gt;</code></li>
</ol>
</li>
</ol>
<h1 id="五-css常用布局">五. CSS常用布局</h1>
<ol>
<li>盒子模型
<ul>
<li>border 设置盒子边框</li>
<li>padding 内边距 元素在盒子中的位置</li>
<li>margin 外边距 盒子的位置</li>
</ul>
</li>
<li>浮动属性
<ul>
<li>float</li>
</ul>
</li>
<li>定位属性 position
<ul>
<li>position:static</li>
<li>position:fixed</li>
<li>position:relative</li>
<li>position:absolute</li>
</ul>
</li>
</ol>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[10分钟系列之html]]></title>
        <id>https://windherd.github.io//post/10分钟系列之html</id>
        <link href="https://windherd.github.io//post/10分钟系列之html">
        </link>
        <updated>2018-07-12T02:25:44.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1ftbk5rry1jj31iu2qx7ku.jpg" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[你有什么道理后悔没有早点知道]]></title>
        <id>https://windherd.github.io//post/你有什么道理后悔没有早点知道</id>
        <link href="https://windherd.github.io//post/你有什么道理后悔没有早点知道">
        </link>
        <updated>2018-07-11T10:26:15.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="你有什么道理后悔没有早点知道">你有什么道理后悔没有早点知道</h1>
<ul>
<li>第一个道理其实是悖论，就是无论我告诉你什么道理，当你的心智没有达到这个境界或接近的水平时或经
过一些事情的时候，你是不会理解这个道理的。或者你以为你知道这个道理，其实你不知道。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1 id="你有什么道理后悔没有早点知道">你有什么道理后悔没有早点知道</h1>
<ul>
<li>
<p>第一个道理其实是悖论，就是无论我告诉你什么道理，当你的心智没有达到这个境界或接近的水平时或经
过一些事情的时候，你是不会理解这个道理的。或者你以为你知道这个道理，其实你不知道。</p>
<!-- more -->
</li>
<li>
<p>第二个很重要的道理是，除了自身的病患或亲友离去的痛苦是真实的，其他的痛苦都是你自己的价值观带给你的。</p>
</li>
<li>
<p>第三个道理是与第二个有关联的，就是别人指责你的事情或批评的你的理由，往往最能伤害你的，是那些你也这样认为的事情。</p>
</li>
<li>
<p>第四个道理是其实人跟人之间差别其实不大，所以不要与别人去比较，人生就是一场长跑，你可能不会是第一名，但也不不太会是最后一名，和前面比你会有动力，和后面比你会有幸福。但重要的是享受过程。</p>
</li>
<li>
<p>第五个道理是永远不要与人去辩论，你也很难把别人辩服，因为立场不同，因为没有对错，只有规则，只有利益。人生就是一场游戏，懂得你在玩的游戏的游戏规则，然后玩好它。
前面五个道理如果你真理解，你会觉得所谓别人的眼光，世俗的看法都不再那么重要，你内心的感觉，你的 时间才最重要</p>
</li>
<li>
<p>第六个道理是人身体的很多器官的受伤是超过一个界限之后不可逆的，比如眼睛过了假性就是真性近视，牙齿牙龈炎症过长一定会让你牙疼并拔牙的，脂肪肝时间过长就是肝硬化，而这些疾病的初期都是可逆的。</p>
</li>
<li>
<p>第七个的道理是生活其实是一种运营，时间是你最宝贵的资源，还有钱，关系，都是你的一种投入，自己重视什么，事业，友谊，家庭上，就多投入些，种瓜得瓜，好好平衡各个关系是你要做好的。</p>
</li>
<li>
<p>第八个道理是要感恩这个世界。如果觉得有触动就应该表达出来。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[10分钟系列之kotlin]]></title>
        <id>https://windherd.github.io//post/10分钟系列之kotlin</id>
        <link href="https://windherd.github.io//post/10分钟系列之kotlin">
        </link>
        <updated>2018-07-11T10:26:15.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="基础语法">基础语法</h2>
<ul>
<li>函数定义使用关键字 fun，参数格式为：参数 : 类型</li>
<li>表达式作为函数体，返回类型自动推断：</li>
<li>函数的变长参数可以用 <strong>vararg</strong> 关键字进行标识：</li>
<li>可变变量定义：var 关键字 . 不可变变量定义：val 关键字，只能赋值一次的变量(类似Java中final修饰的变量)</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h2 id="基础语法">基础语法</h2>
<ul>
<li>函数定义使用关键字 fun，参数格式为：参数 : 类型</li>
<li>表达式作为函数体，返回类型自动推断：</li>
<li>函数的变长参数可以用 <strong>vararg</strong> 关键字进行标识：</li>
<li>可变变量定义：var 关键字 . 不可变变量定义：val 关键字，只能赋值一次的变量(类似Java中final修饰的变量)</li>
</ul>
<!--more-->
<ul>
<li>
<p>常量与变量都可以没有初始化值,但是在引用前必须初始化</p>
<p>编译器支持自动类型判断,即声明时可以不指定类型,由编译器判断。</p>
</li>
<li>
<p>$varName 表示变量值</p>
<p>${varName.fun()} 表示变量的方法返回值:</p>
</li>
<li></li>
<li>
<pre><code>//类型后面加?表示可为空
var age: String? = &quot;23&quot; 
//抛出空指针异常
val ages = age!!.toInt()
//不做处理返回 null
val ages1 = age?.toInt()
//age为空返回-1
val ages2 = age?.toInt() ?: -1
</code></pre>
</li>
<li>
<p>可以使用 is 运算符检测一个表达式是否某类型的一个实例(类似于Java中的instanceof关键字)。</p>
</li>
</ul>
<h2 id="基本数据类型">基本数据类型</h2>
<ul>
<li>Byte.Short.Int.Long.Float.Double.字符不属于数值类型，是一个独立的数据类型。</li>
<li>使用下划线使数字常量更易读：val oneMillion=1_000_000</li>
<li>三个等号 === 表示比较对象地址，两个 == 表示比较两个值大小</li>
<li>较小类型并不是较大类型的子类型，较小的类型不能隐式转换为较大的类型</li>
<li>数组用Array，还有ByteArray, ShortArray, IntArray,省去了装箱的操作,效率更高</li>
<li>三个引号 &quot;&quot;&quot; 扩起来的字符串，支持多行字符串</li>
<li>String 可以通过 trimMargin() 方法来删除多余的空白。</li>
</ul>
<h2 id="条件控制">条件控制</h2>
<ul>
<li>
<p>可以把 IF 表达式的结果赋值给一个变量</p>
<pre><code class="language-kotlin">val max=if(a&gt;b){
    a
}else{
    b
}
</code></pre>
</li>
<li>
<p>不需要三元操作符<code>val c=if(condition) a else b</code></p>
</li>
<li>
<p>用 in 运算符来检测某个数字是否在指定区间内，区间格式为 x..y ：</p>
</li>
<li>
<p>when 类似其他语言的 switch 操作符</p>
<pre><code class="language-kotlin">when(x){
    1-&gt;print(&quot;x==1&quot;)
    2-&gt;print(&quot;x==2&quot;)
    in 3..10-&gt;print(&quot;x in 3..10&quot;)
    !11-&gt;print(&quot;x not 11&quot;)
    else-&gt;{
        print(&quot;x else&quot;)
    }
}
</code></pre>
</li>
</ul>
<h2 id="循环控制">循环控制</h2>
<ul>
<li>
<p>for (item in collection)  print(item)</p>
<pre><code class="language-kotlin">for(item:Int in ints){
    //...
}
for(i in array.indices){
    //array[i]
}
for((index,value)in array.withIndex()){
    prinln(&quot;the element at $index is $value&quot;)
}
</code></pre>
</li>
<li>
<p>while与do...while</p>
</li>
<li>
<p>在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@</p>
<pre><code class="language-kotlin">loop@ for(i in 1..100){
    for(j in 1..100){
       if(..){
        break@loop
    	}  
    }
}
</code></pre>
</li>
</ul>
<h2 id="类和对象">类和对象</h2>
<ul>
<li>
<p>koltin 中的类可以有一个 主构造器，以及一个或多个次构造器，主构造器是类头部的一部分，位于类名称之后</p>
</li>
<li>
<p>类也可以有二级构造函数，需要加前缀 constructor:</p>
<pre><code class="language-kotlin">class Person constructor(firstName: String) {}

class Person constructor(firstName: String){
    //二级构造函数
    constructor(parent:Person,firstName: String):this(firstName){
        parent.children.add(this)
    }
}
</code></pre>
</li>
<li>
<p>如果一个非抽象类没有声明构造函数(主构造函数或次构造函数)，它会产生一个没有参数的构造函数。构造函数是 public 。如果你不想你的类有公共的构造函数，你就得声明一个空的主构造函数：</p>
<pre><code class="language-kotlin">class DontCreateMe private constructor(){}
</code></pre>
</li>
<li>
<p>如果主构造器没有任何注解，也没有任何可见度修饰符，那么constructor关键字可以省略</p>
</li>
<li>
<p>注意如果主构造函数的所有参数都有默认值，编译器会生成一个附加的无参的构造函数，这个构造函数会直接使用默认值</p>
<pre><code class="language-kotlin">class Customer(val customerName: String = &quot;&quot;)
</code></pre>
</li>
<li>
<p>Kotlin 中类不能有字段。提供了 Backing Fields(后端变量) 机制,备用字段使用field关键字声明,field 关键词只能用于属性的访问器</p>
<pre><code class="language-kotlin">var no:Int=100
		get()=field
		set(value){
            if(value&lt;10){
                field=value
            }else{
                field=-1
            }
		}
</code></pre>
</li>
<li>
<p>构造器中不能包含任何代码，初始化代码可以放在初始化代码段中，初始化代码段使用 init 关键字作为前缀</p>
<pre><code class="language-kotlin">class Person constructor(name:String){
    init{
        println(&quot;name is $name&quot;)
    }
}
</code></pre>
</li>
<li>
<p>内部类使用 inner 关键字来表示,不用inner表示的类里面写的类无法访问外部类的成员</p>
</li>
<li>
<p>类的修饰符classModifier 和_accessModifier_:</p>
<ul>
<li>classModifier</li>
</ul>
<pre><code class="language-kotlin">abstract    // 抽象类  
final       // 类不可继承，默认属性
enum        // 枚举类
open        // 类可继承，类默认是final的
annotation  // 注解类
</code></pre>
<ul>
<li>accessModifier</li>
</ul>
<pre><code class="language-kotlin">private    // 仅在同一个文件中可见
protected  // 同一个文件中或子类可见
public     // 所有调用的地方都可见
internal   // 同一个模块中可见
</code></pre>
</li>
</ul>
<h2 id="继承">继承</h2>
<ul>
<li>
<p>Kotlin 中所有类都继承该 Any 类，它是所有类的超类(Any 不是 java.lang.Object)</p>
<pre><code class="language-kotlin">equals()

hashCode()

toString()
</code></pre>
</li>
<li>
<p>如果一个类要被继承，可以使用 open 关键字进行修饰</p>
</li>
<li>
<p>如果子类有主构造函数， 则基类必须在主构造函数中立即初始化.如果子类没有主构造函数，则必须在每一个二级构造函数中用 super 关键字初始化基类，或者在代理另一个构造函数。初始化基类时，可以调用基类的不同构造方法</p>
<pre><code class="language-kotlin">//没有主构造函数
class Student:Persion{
    constructor(ctx:Context):super(ctx){
        
    }
     constructor(ctx:Context,attr:AttributeSet):super(ctx,attr){
        
    }
}
</code></pre>
</li>
<li>
<p>使用fun声明函数时，此函数默认为final修饰，不能被子类重写。如果允许子类重写该函数，那么就要手动添加 open 修饰</p>
</li>
<li>
<p>属性重写使用 override 关键字，属性必须具有兼容类型，每一个声明的属性都可以通过初始化程序或者getter方法被重写</p>
</li>
<li>
<p>可以用一个var属性重写一个val属性，但是反过来不行。因为val属性本身定义了getter方法，重写为var属性会在衍生类中额外声明一个setter方法</p>
<pre><code class="language-kotlin">interface Foo {
    val count: Int
}

class Bar1(override val count: Int) : Foo

class Bar2 : Foo {
    override var count: Int = 0
}
</code></pre>
</li>
</ul>
<h2 id="接口">接口</h2>
<ul>
<li>
<p>Kotlin 接口与 Java 8 类似，使用 interface 关键字定义接口，允许方法有默认实现：</p>
</li>
<li>
<p>接口中的属性只能是抽象的，不允许初始化值，接口不会保存属性值，实现接口时，必须重写属性</p>
</li>
<li>
<p>实现多个接口时，遇到同一方法继承多个实现的时候</p>
<pre><code class="language-kotlin">interface A {
    fun foo() { print(&quot;A&quot;) }   // 已实现
    fun bar()                  // 未实现，没有方法体，是抽象的
}
 
interface B {
    fun foo() { print(&quot;B&quot;) }   // 已实现
    fun bar() { print(&quot;bar&quot;) } // 已实现
}
class C: A, B{
    override fun foo(){
        super&lt;A&gt;.foo()
        super&lt;B&gt;.foo()
    }
    override fun bar(){
        super&lt;B&gt;.bar()
    }
}
fun main(args: Array&lt;String&gt;) {
    val c =  C()
    c.foo();
    c.bar();
    //ABbar
}
</code></pre>
</li>
</ul>
<h2 id="扩展">扩展</h2>
<ul>
<li>
<p>Kotlin 可以对一个类的属性和方法进行扩展，且不需要继承或使用 Decorator 模式</p>
<p>扩展是一种静态行为，对被扩展的类代码本身不会造成任何影响。</p>
</li>
<li>
<p>扩展函数可以在已有类中添加新的方法</p>
<pre><code class="language-kotlin">fun receiverType.functionName(params){
    body
}
//receiverType：表示函数的接收者，也就是函数扩展的对象
//functionName：扩展函数的名称
//params：扩展函数的参数，可以为NULL
</code></pre>
</li>
<li>
<p>扩展函数是静态解析的，并不是接收者类型的虚拟成员，在调用扩展函数时，具体被调用的的是哪一个函数，由调用函数的的对象表达式来决定的，而不是动态的类型决定的</p>
<pre><code class="language-kotlin">open class C

class D: C()

fun C.foo() = &quot;c&quot;   // 扩展函数 foo

fun D.foo() = &quot;d&quot;   // 扩展函数 foo

fun printFoo(c: C) {
    println(c.foo())  // 类型是 C 类
}

fun main(arg:Array&lt;String&gt;){
    printFoo(D())//输出c
}
</code></pre>
</li>
<li>
<p>若扩展函数和成员函数一致，则使用该函数时，会优先使用成员函数</p>
<pre><code class="language-kotlin">class C {
    fun foo() { println(&quot;成员函数&quot;) }
}

fun C.foo() { println(&quot;扩展函数&quot;) }

fun main(arg:Array&lt;String&gt;){
    var c = C()
    c.foo()//成员函数
}
</code></pre>
</li>
</ul>
<h2 id="数据类与密封类">数据类与密封类</h2>
<ul>
<li>
<p>Kotlin 可以创建一个只包含数据的类，关键字为 data</p>
<pre><code>数据类需要满足以下条件(保证生成代码的一致性以及有意义):

主构造函数至少包含一个参数。
所有的主构造函数的参数必须标识为val 或者 var ;
数据类不可以声明为 abstract, open, sealed 或者 inner;
数据类不能继承其他类 (但是可以实现接口)。
</code></pre>
</li>
<li>
<p>复制使用 copy() 函数，我们可以使用该函数复制对象并修改部分属性</p>
<pre><code class="language-kotlin">data class User(val name: String, val age: Int)
fun main(args: Array&lt;String&gt;) {
    val jack = User(name = &quot;Jack&quot;, age = 1)
    val olderJack = jack.copy(age = 2)
    println(jack)
    println(olderJack)
}
</code></pre>
</li>
<li>
<p>sealed密封类用来表示受限的类继承结构.当一个值为有限几种的类型, 而不能有任何其他类型时.在某种意义上，他们是枚举类的扩展.但每个枚举常量只存在一个实例，而密封类 的一个子类可以有可包含状态的多个实例.密封类可以有子类，但是所有的子类都必须要内嵌在密封类中。</p>
</li>
<li>
<p>sealed 不能修饰 interface ,abstract class(会报 warning,但是不会出现编译错误)</p>
<pre><code class="language-kotlin">sealed class Expr
data class Const(val number: Double) : Expr()
data class Sum(val e1: Expr, val e2: Expr) : Expr()
object NotANumber : Expr()

fun eval(expr: Expr): Double = when(expr) {
    is Expr.Const -&gt; expr.number
    is Expr.Sum -&gt; eval(expr.e1) + eval(expr.e2)
    Expr.NotANumber -&gt; Double.NaN
    // 使用 when 表达式时不再需要 `else` 子句，因为我们已经覆盖了所有的情况
}
</code></pre>
</li>
</ul>
<h2 id="泛型">泛型</h2>
<pre><code class="language-kotlin">class Box&lt;T&gt;(t:T){
    var value=t
}
val box :Box&lt;Int&gt;=Box&lt;Int&gt;(1)
或者
val box =Box(1)
</code></pre>
<ul>
<li>
<p>泛型约束:可以使用泛型约束来设定一个给定参数允许使用的类型</p>
<pre><code class="language-kotlin">fun &lt;T : Comparable&lt;T&gt;&gt; sort(list: List&lt;T&gt;) {
    // ……
}
sort(listOf(1, 2, 3)) // OK。Int 是 Comparable&lt;Int&gt; 的子类型
sort(listOf(HashMap&lt;Int, String&gt;())) // 错误：HashMap&lt;Int, String&gt; 不是 Comparable&lt;HashMap&lt;Int, String&gt;&gt; 的子类型
</code></pre>
</li>
</ul>
<h2 id="枚举类">枚举类</h2>
<pre><code class="language-kotlin">enum class Color{
   RED,BLACK,BLUE,GREEN,WHITE   
}
//枚举初始化
enum class Color(val rgb: Int) {
    RED(0xFF0000),
    GREEN(0x00FF00),
    BLUE(0x0000FF)
}
</code></pre>
<ul>
<li>
<p>使用枚举常量</p>
<pre><code class="language-kotlin">enum class Color{
    RED,BLACK,BLUE,GREEN,WHITE
}

fun main(args: Array&lt;String&gt;) {
    var color:Color=Color.BLUE

    println(Color.values())//以数组的形式，返回枚举值
    println(Color.valueOf(&quot;RED&quot;))//转换指定 name 为枚举值，若未匹配成功，会抛出IllegalArgumentException
    println(color.name)
    println(color.ordinal)
}
</code></pre>
</li>
</ul>
<h2 id="对象表达式声明">对象表达式/声明</h2>
<ul>
<li>
<p>匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的 返回类型或者用作公有属性的类型，那么该函数或属性的实际类型 会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。在匿名对象 中添加的成员将无法访问。</p>
<pre><code class="language-kotlin">class C {
    // 私有函数，所以其返回类型是匿名对象类型
    private fun foo() = object {
        val x: String = &quot;x&quot;
    }

    // 公有函数，所以其返回类型是 Any
    fun publicFoo() = object {
        val x: String = &quot;x&quot;
    }

    fun bar() {
        val x1 = foo().x        // 没问题
        val x2 = publicFoo().x  // 错误：未能解析的引用“x”
    }
}

</code></pre>
</li>
<li>
<p>Kotlin 使用 object 关键字来声明一个对象</p>
</li>
<li>
<p>当对象声明在另一个类的内部时，这个对象并不能通过外部类的实例访问到该对象，而只能通过类名来访问，同样该对象也不能直接访问到外部类的方法和变量</p>
<pre><code class="language-kotlin">lass Site {
    var name = &quot;github&quot;
    object DeskTop{
        var url = &quot;www.github.com&quot;
        fun showName(){
            print{&quot;desk legs $name&quot;} // 错误，不能访问到外部类的方法和变量
        }
    }
}
fun main(args: Array&lt;String&gt;) {
    var site = Site()
    site.DeskTop.url // 错误，不能通过外部类的实例访问到该对象
    Site.DeskTop.url // 正确
}
</code></pre>
</li>
<li>
<p>类内部的对象声明可以用 companion 关键字标记，这样它就与外部类关联在一起，我们就可以直接通过外部类访问到对象的内部元素</p>
<pre><code class="language-kotlin">class MyClass {
    companion object Factory {
        fun create(): MyClass = MyClass()
    }
}
val instance = MyClass.create()   // 访问到对象的内部元素
     		********
//可以省略掉该对象的对象名，然后使用 Companion 替代需要声明的对象名
class MyClass {
    companion object {
    }
}
val x = MyClass.Companion
</code></pre>
</li>
<li>
<p>个类里面只能声明一个内部关联对象，即关键字 companion 只能使用一次</p>
</li>
<li>
<p>对象表达式和对象声明之间的语义差异</p>
<ul>
<li>对象表达式是在使用他们的地方立即执行的</li>
<li>对象声明是在第一次被访问到时延迟初始化的</li>
<li>伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配</li>
</ul>
</li>
</ul>
<h2 id="委托">委托</h2>
<ul>
<li>
<p>有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理</p>
</li>
<li>
<p>类委托. Derived 声明中，by 子句表示，将 b 保存在 Derived 的对象实例内部，而且编译器将会生成继承自 Base 接口的所有方法, 并将调用转发给 b。</p>
<pre><code class="language-kotlin">// 创建接口
interface Base {   
    fun print()
}

// 实现此接口的被委托的类
class BaseImpl(val x: Int) : Base {
    override fun print() { print(x) }
}

// 通过关键字 by 建立委托类
class Derived(b: Base) : Base by b

fun main(args: Array&lt;String&gt;) {
    val b = BaseImpl(10)
    Derived(b).print() // 输出 10
}
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[baby]]></title>
        <id>https://windherd.github.io//post/baby</id>
        <link href="https://windherd.github.io//post/baby">
        </link>
        <updated>2017-08-17T05:16:21.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>Since I left you, I have been constantly depressed. My happiness is to be near you. Incessantly I live over in my memory your caresses, your tears, your affectionate solicitude. The charms of the incomparable Josephine kindle continually a burning and a glowing flame in my heart. When, free from all solicitude, all harassing care, shall I be able to pass all my time with you, having only to love you, and to think only of the happiness of so saying, and of proving it to you?</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>Since I left you, I have been constantly depressed. My happiness is to be near you. Incessantly I live over in my memory your caresses, your tears, your affectionate solicitude. The charms of the incomparable Josephine kindle continually a burning and a glowing flame in my heart. When, free from all solicitude, all harassing care, shall I be able to pass all my time with you, having only to love you, and to think only of the happiness of so saying, and of proving it to you?</p>
</blockquote>
<!--more-->
<ul>
<li>
<p>只要心在跳动, 就有血的潮汐</p>
</li>
<li>
<p>而你的微笑将印在红色的月亮上</p>
</li>
<li>
<p>每夜升起在我的小窗前</p>
</li>
<li>
<p>唤醒记忆</p>
</li>
<li>
<p>我在等你, 我在想你</p>
</li>
</ul>
<blockquote>
<p>眼为你下雨, 心为你遮伞</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[向温暖的地方靠近]]></title>
        <id>https://windherd.github.io//post/missthedistance</id>
        <link href="https://windherd.github.io//post/missthedistance">
        </link>
        <updated>2017-06-01T11:07:25.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>花期以至</li>
<li>朝露未晞</li>
<li>不如你好看的样子</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>花期以至</li>
<li>朝露未晞</li>
<li>不如你好看的样子</li>
</ul>
<!--more-->
<ul>
<li>
<p>打理好花园</p>
</li>
<li>
<p>收拾好庭院</p>
</li>
<li>
<p>等你来,拨动琴弦</p>
</li>
<li>
<p>你就像星星 撞到我的怀里</p>
</li>
<li>
<p>不早不晚 不偏不倚</p>
</li>
<li>
<p>好幸运</p>
</li>
<li>
<p>写了首关于你的诗</p>
</li>
<li>
<p>在窗前徘徊好多次</p>
</li>
<li>
<p>谢谢你给了我 你心的地址</p>
</li>
<li>
<p>有你的夏天</p>
</li>
<li>
<p>云很懒 风很甜</p>
</li>
<li>
<p>不  是你坠入凡间的每一天</p>
</li>
<li>
<p>和你吵架了</p>
</li>
<li>
<p>不想说话</p>
</li>
<li>
<p>好吧 我认输 我又想你了</p>
</li>
<li>
<p>我想去流浪 有你有诗有远方...</p>
<p>​</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[刚好遇见你]]></title>
        <id>https://windherd.github.io//post/JustMetYou</id>
        <link href="https://windherd.github.io//post/JustMetYou">
        </link>
        <updated>2017-03-24T11:11:43.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>当遇见你时，</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>
<p>当遇见你时，</p>
<!--more-->
</li>
<li>
<p>我才知道幸福是什么。</p>
</li>
<li>
<p>幸福就是眼睛可以看着你，</p>
</li>
<li>
<p>耳朵可以听着你的声音。</p>
</li>
<li>
<p>要是再能牵着你的手，</p>
</li>
<li>
<p>那就幸福的天翻地覆了。</p>
</li>
<li>
<p>当遇见你时，</p>
</li>
<li>
<p>我才知道满足是什么。</p>
</li>
<li>
<p>满足就是和你在一起，</p>
</li>
<li>
<p>世上的财富和地位都已黯然失色。</p>
</li>
<li>
<p>你就是我的世界，</p>
</li>
<li>
<p>和你在一起生活才有意义</p>
</li>
</ul>
]]></content>
    </entry>
</feed>