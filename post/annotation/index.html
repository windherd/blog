<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>注解 | 风中追风</title>
<meta name="description" content="Maintain curiosity, to maintain pure heart.">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://windherd.github.io//favicon.ico?v=1560853640325">
<!--字体-->
<link href="https://fonts.googleapis.com/css?family=Gloria+Hallelujah|Libre+Barcode+39" rel="stylesheet">
<!--主要CSS-->
<link rel="stylesheet" href="https://windherd.github.io//styles/main.css">
<style type="text/css">
      .tilt{
        margin: 0;
        overflow: hidden;
        width: 100vw;
        height: 100vh;
        background: #49beb7;
        background: linear-gradient(to top left, #4CB8C4 -40%, #2196F3);
        position:fixed;
        top:0;
        left:0;
        z-index: 999 !important;
      }
      .container {
        position: absolute;
        top:0;
        bottom: 0;
        left: 0;
        right: 0;
        width: 250px;
        height: 250px;
        margin: auto;
      }

      .part {
        width: 250px;
        position: absolute;
      }

      .svgpath {
        fill: rgba(145,220,90,0);
        stroke: aqua;
        stroke-width: 1.5px;
        stroke-dasharray: 1000;
        stroke-linecap: round;
        z-index: 2;
      }

      .svgbg {
        fill: rgba(255,255,255,0.2);
        z-index: 1;
       }

      #playload {
        animation: dash 2.5s reverse ease-in-out infinite;
      }

      @keyframes dash {
        to {
          stroke-dashoffset: 2000;
        }
      }</style>


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  



<script src="https://windherd.github.io//media/dict/js/Vue.js"></script>
<script src="https://windherd.github.io//media/dict/js/JQuery.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://windherd.github.io//media/dict/css/aos.css" />





  </head>
  <body>
    <div class="tilt">
      <div class='container'>
        <svg class='part' x="0px" y="0px" viewBox="0 0 256 256" style="enable-background:new 0 0 256 256;" xml:space="preserve">
          <path class="svgpath" id="playload" d="M189.5,140.5c-6.6,29.1-32.6,50.9-63.7,50.9c-36.1,0-65.3-29.3-65.3-65.3
        c0,0,17,0,23.5,0c10.4,0,6.6-45.9,11-46c5.2-0.1,3.6,94.8,7.4,94.8c4.1,0,4.1-92.9,8.2-92.9c4.1,0,4.1,83,8.1,83
        c4.1,0,4.1-73.6,8.1-73.6c4.1,0,4.1,63.9,8.1,63.9c4.1,0,4.1-53.9,8.1-53.9c4.1,0,4.1,44.1,8.2,44.1c4.1,0,3.1-34.5,7.2-34.5
        c4.1,0,3.1,24.6,7.2,24.6c4.1,0,2.5-14.5,5.2-14.5c2.2,0,0.8,5.1,4.2,4.9c0.4,0,13.1,0,13.1,0c0-34.4-27.9-62.3-62.3-62.3
        c-27.4,0-50.7,17.7-59,42.3" />

          <path class="svgbg" d="M61,126c0,0,16.4,0,23,0c10.4,0,6.6-45.9,11-46c5.2-0.1,3.6,94.8,7.4,94.8c4.1,0,4.1-92.9,8.2-92.9
        c4.1,0,4.1,83,8.1,83c4.1,0,4.1-73.6,8.1-73.6c4.1,0,4.1,63.9,8.1,63.9c4.1,0,4.1-53.9,8.1-53.9c4.1,0,4.1,44.1,8.2,44.1
        c4.1,0,3.1-34.5,7.2-34.5c4.1,0,3.1,24.6,7.2,24.6c4.1,0,2.5-14.5,5.2-14.5c2.2,0,0.8,5.1,4.2,4.9c0.4,0,22.5,0,23,0" />
        </svg></div> 
    </div>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">

  <div class="overlay"></div>
  <div class="top-container" data-aos="fade-right">
    <!--头像-->
    <div class="top-header-container">
      <a class="site-title-container" href="https://windherd.github.io/">
        <img src="https://windherd.github.io//images/avatar.png?v=1560853640325" class="site-logo">
      </a>
      <h1 class="site-title">
            风中追风
            <p></p>
        </h1>
    </div>
    <!--导航-->
    <div class="top-header-nav">


      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
    <div class="icons">
        <ul>
          <li v-for="(le,index) in alin.like">
            <a :href="le.aim" :alt="le.alt">
              <img :src="le.src" />
            </a>
          </li>
        </ul>
    </div> 

  </div>


  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
      <div class="site-footer">
          Powered by <a href="https://github.com/windherd" target="_blank">windherd</a>
      </div>
      <div class="site-description">
          <p><a href="#">Maintain curiosity, to maintain pure heart.</a></p>
          <p>
            
            <span>&nbsp;</span>
            Powered by <a href="https://gridea.dev">Gridea</a>
            <span>•</span>Theme <a href="http://www.itaolaity.com/">Alin</a>
          </p>
      </div>
  </div>
</div>



      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">注解</h2>
            <div class="post-date">2017-01-19</div>
            
              <div class="feature-container" style="background-image: url('https://windherd.github.io//post-images/annotation.jpg')">
              </div>
            
            <div class="post-content">
              <p>1.使用IntDef代替枚举</p>
<p>枚举一直不被Android中推荐使用.因为枚举中的每一个值在枚举类中都是一个对象.使用枚举值会比整型消耗的更多的内存.但有时我们又要限制取某些特定的值.intDef和StringDef两个魔术变量注解来替换枚举.厉害了,我的哥.</p>
<!--more-->
<p>步骤:</p>
<ol>
<li>声明一些必要的int(或者float,String等)常量</li>
<li>声明一个注解ThemeStyle</li>
<li>使用@intDef修饰ThemeStyle,参数设置为待枚举的集合</li>
<li>使用@Retention(Retention.SOURCE)指定注解仅存在于源码中,不加入到class文件中</li>
</ol>
<p>具体使用:</p>
<pre><code>public static final int STYLE_V1 = 0; // 单排排版
public static final int STYLE_V2 = 1; // 双排排版
 @IntDef({STYLE_V1,STYLE_V2})
 @Retention(RetentionPolicy.SOURCE)
 public @interface ThemeStyle{
 }
 //这样外部调用的时候只能传ThemeStyle.STYLE_V1,或者ThemeStyle.STYLE_V2.否则编译报错
  public static void setStyle(Context context, @ThemeStyle int style) {
   ...
 }
</code></pre>
<p>2.几种Threading注解</p>
<p>@UiThread UI线程</p>
<p>@MainThread 主线程</p>
<p>@WorkerThread 子线程</p>
<p>@BinderThread 绑定线程</p>
<p>3.Value Constraints注解: @Size,@IntRange@FloatRange</p>
<pre><code class="language-java">private void test(@IntRange(from=0,to=100)int a){
}
//举例
@Size(min=1)集合长度最小为1,即不能为空
@Size(max=100)String最大只能有100个字符
@size(2)数组只能有两个元素
</code></pre>
<p>4.@Permissions注解:@RequiresPermission</p>
<ul>
<li>单一权限</li>
</ul>
<pre><code class="language-java">@RequiresPermission(Manifest.permission.INTERNET)
public void loadData(){
  ...
}
</code></pre>
<ul>
<li>需要任意一个</li>
</ul>
<pre><code class="language-java">@RequiresPermission(anyOf={Manifest.permission.INTERNET,...})
public void loadData(){
  ...
}
</code></pre>
<ul>
<li>同时需要多个</li>
</ul>
<pre><code class="language-java">@RequiresPermission(allOf={Manifest.permission.INTERNET,...})
public void loadData(){
  ...
}
</code></pre>
<p>5.@CallSuper</p>
<p>允许子类重写的方法,但是又需要在重写的时候调用自己的方法.为避免子类完全重写不调用自己的方法可用这个注解</p>
<pre><code class="language-java">@CallSuper
protected void onCreate(@nullable){
 doSoming()
}
</code></pre>
<p>6.@Keep</p>
<p>指出一个方法在被混淆时被保留</p>
<p>7.@VisibleForTesting</p>
<p>注解一个类,方法,变量表示有更广的可见性,使代码可以被测试</p>
<h2 id="注解">注解</h2>
<p>@Retention、@Documented、@Target、@Inherited、@Repeatable</p>
<ul>
<li>@Retention</li>
</ul>
<blockquote>
<ul>
<li>RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。</li>
<li>RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。</li>
<li>RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。</li>
</ul>
</blockquote>
<hr>
<ul>
<li>@Target</li>
</ul>
<blockquote>
<ul>
<li>
<p>ElementType.ANNOTATION_TYPE 可以给一个注解进行注解</p>
</li>
<li>
<p>ElementType.CONSTRUCTOR 可以给构造方法进行注解</p>
</li>
<li>
<p>ElementType.FIELD 可以给属性进行注解</p>
</li>
<li>
<p>ElementType.LOCAL_VARIABLE 可以给局部变量进行注解</p>
</li>
<li>
<p>ElementType.METHOD 可以给方法进行注解</p>
</li>
<li>
<p>ElementType.PACKAGE 可以给一个包进行注解</p>
</li>
<li>
<p>ElementType.PARAMETER 可以给一个方法内的参数进行注解</p>
</li>
<li>
<p>ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举</p>
</li>
</ul>
</blockquote>
<ul>
<li>
<p>注解的属性也叫做成员变量。注解只有成员变量，没有方法。</p>
<p>注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。</p>
<pre><code>@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface TestAnnotation {

    public int id() default -1;

    public String msg() default &quot;Hi&quot;;

}
</code></pre>
</li>
<li>
<p>如果一个注解内仅仅只有一个名字为 value 的属性时，应用这个注解时可以直接接属性值填写到括号内。</p>
<pre><code>@Check(&quot;hi&quot;)
int a;
</code></pre>
</li>
<li>
<p>是一个注解没有任何属性。比如</p>
<pre><code>public @interface Perform {}
</code></pre>
<p>那么在应用这个注解的时候，括号都可以省略。</p>
<pre><code>@Perform
public void testMethod(){}
</code></pre>
</li>
</ul>
<h2 id="java预置的注解">java预置的注解</h2>
<ul>
<li>
<p>@Deprecated</p>
<p>过时的方法、过时的类、过时的成员变量</p>
</li>
<li>
<p>@Override</p>
</li>
<li>
<p>@SuppressWarnings</p>
<p>阻止警告的意思</p>
<pre><code>@SuppressWarnings(&quot;deprecation&quot;)
public void test1(){
    Hero hero = new Hero();
    hero.say();
    hero.speak();
}
</code></pre>
</li>
<li>
<p>FunctionalInterface</p>
<p>函数式接口注解.是一个具有一个方法的普通接口</p>
</li>
</ul>
<h2 id="注解与反射">注解与反射</h2>
<ol>
<li>
<p>注解通过反射获取。首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解</p>
<pre><code>public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {}
</code></pre>
</li>
<li>
<p>然后通过 getAnnotation() 方法来获取 Annotation 对象</p>
<pre><code>public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {}
</code></pre>
<p>或者是getAnnotations() 方法</p>
<pre><code>public Annotation[] getAnnotations() {}
</code></pre>
<p>前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解</p>
</li>
<li>
<p>如果获取到的 Annotation 如果不为 null，则就可以调用它们的属性方法了</p>
<pre><code>@TestAnnotation
public class Test {
    @Check(&quot;hi&quot;)
    int a;

    @Perform
    public void testMethod() {
    }

    @SuppressWarnings(&quot;deprecation&quot;)
    public void test1() {
        Hero hero = new Hero();
        hero.say();
        hero.speak();

    }

    public static void main(String[] args) {
        boolean hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class);
        if (hasAnnotation) {
            //获取类的注解
            TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class);
            System.out.println(&quot;id:&quot; + testAnnotation.id());
            System.out.println(&quot;msg:&quot; + testAnnotation.msg());
        }
        try {
            Field a = Test.class.getDeclaredField(&quot;a&quot;);
            a.setAccessible(true);
            //获取一个成员变量上的注解
            Check check = a.getAnnotation(Check.class);
            if (check != null) {
                System.out.println(&quot;check value:&quot; + check.value());
            }

            Method testMethod = Test.class.getDeclaredMethod(&quot;testMethod&quot;);
            if (testMethod != null) {
                // 获取方法中的注解
                Annotation[] nas = testMethod.getAnnotations();
                for (int i = 0; i &lt; nas.length; i++) {
                    System.out.println(&quot;method testMethod annotation:&quot; + nas[i].annotationType().getSimpleName());
                }
            }
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
</li>
<li>
<p>如果一个注解要在运行时被成功提取，那么 @Retention(RetentionPolicy.RUNTIME) 是必须的</p>
</li>
</ol>
<h2 id="使用场景">使用场景</h2>
<ul>
<li>当开发者使用了Annotation 修饰了类、方法、Field 等成员之后，这些 Annotation 不会自己生效，必须由开发者提供相应的代码来提取并处理 Annotation 信息。这些处理提取和处理 Annotation 的代码统称为 APT（Annotation Processing Tool)。</li>
</ul>
<h2 id="总结">总结</h2>
<ol>
<li>如果注解难于理解，你就把它类同于标签，标签为了解释事物，注解为了解释代码。</li>
<li>注解的基本语法，创建如同接口，但是多了个 @ 符号。</li>
<li>注解的元注解。</li>
<li>注解的属性。</li>
<li>注解主要给编译器及工具类型的软件用的。</li>
<li>注解的提取需要借助于 Java 的反射技术，反射比较慢慢，所以注解使用时也需要谨慎计较时间成本</li>
</ol>
<blockquote>
<p>保持求知欲,保持赤子心(*╯3╰)mua.</p>
</blockquote>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://windherd.github.io//tag/android" class="tag">
                    Android
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://windherd.github.io//post/gitcommandline">
                  <h3 class="post-title">
                    git常用操作
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <footer>
	<div class="foo-con">
    	<p><a href="#">Maintain curiosity, to maintain pure heart.</a></p>
      	<p>
	        
	        <span>&nbsp;</span>
	        Powered by <a href="https://gridea.dev">Gridea</a>
	        <span>•</span>Theme <a href="http://www.itaolaity.com/">Alin</a>
     	</p>
    </div>
</footer>



<script src="https://windherd.github.io//media/dict/js/aos.js"></script>

<!--Self-->
<script>
    $(window).on('load',function(){ 
  　　$('.tilt').fadeOut(1000);
　　}); 
</script>


<script type="application/javascript">

/*动画初始化*/
AOS.init(
  {
  offset: 200,
  duration: 600,
  easing: 'ease-in-sine',
  delay: 100,
  }
);

/*代码高亮*/
hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible:false,
    alin:{
      like:[
          {
            "alt":"我的博客",
            "aim":"http://www.itaolaity.com/index.php",
            "src":"http://itaolaity.com/20190429220545.png"
          },
          {
            "alt":"GitHub",
            "aim":"https://github.com/taoya7",
            "src":"http://itaolaity.com/20190429220612.png"
          },
          {
            "alt":"Email",
            "aim":"mailto:569781231@qq.com",
            "src":"http://itaolaity.com/20190429220636.png"
          }
      ]
    }
  }
});

</script>




  
  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: 'c3a23f028ffa157f67f9',
        clientSecret: 'd9b1f603641c849e309d3273da20035201edbb32',
        repo: 'windherd.github.io',
        owner: 'windherd',
        admin: ['windherd'],
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




    <script>
      //添加SVG代码
      var svg = '<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="14" viewBox="20"><g fill="none" fill-rule="evenodd" transform="translate(1 1)"><circle cx="6" cy="6" r="6" fill="#FF5F56" stroke="#E0443E" stroke-width=".5"></circle><circle cx="26" cy="6" r="6" fill="#FFBD2E" stroke="#DEA123" stroke-width=".5"></circle><circle cx="46" cy="6" r="6" fill="#27C93F" stroke="#1AAB29" stroke-width=".5"></circle></g></svg>';
      var code = document.querySelectorAll(".post-content pre code");
      for(var i=0; i<code.length; i++){
          code[i].insertAdjacentHTML("beforebegin", svg);
      }
      //注册添加Class
      $('.post-detail h1,h2,h3,h4,h5').addClass("iconfont");


    </script>
  </body>
</html>
