<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>10分钟系列之kotlin | 风中追风</title>
<link rel="shortcut icon" href="https://windherd.github.io//favicon.ico?v=1560851148347">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://windherd.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://windherd.github.io/">
  <img class="avatar" src="https://windherd.github.io//images/avatar.png?v=1560851148347" alt="">
  </a>
  <h1 class="site-title">
    风中追风
  </h1>
  <p class="site-description">
    Maintain curiosity, to maintain pure heart.
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/windherd" target="_blank">
          <i class="fab fa-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              10分钟系列之kotlin
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2018-07-11 ·
              </time>
              
                <a href="https://windherd.github.io//tag/android" class="post-tag">
                  # Android
                </a>
              
            </div>
            
            <div class="post-content">
              <h2 id="基础语法">基础语法</h2>
<ul>
<li>函数定义使用关键字 fun，参数格式为：参数 : 类型</li>
<li>表达式作为函数体，返回类型自动推断：</li>
<li>函数的变长参数可以用 <strong>vararg</strong> 关键字进行标识：</li>
<li>可变变量定义：var 关键字 . 不可变变量定义：val 关键字，只能赋值一次的变量(类似Java中final修饰的变量)</li>
</ul>
<!--more-->
<ul>
<li>
<p>常量与变量都可以没有初始化值,但是在引用前必须初始化</p>
<p>编译器支持自动类型判断,即声明时可以不指定类型,由编译器判断。</p>
</li>
<li>
<p>$varName 表示变量值</p>
<p>${varName.fun()} 表示变量的方法返回值:</p>
</li>
<li></li>
<li>
<pre><code>//类型后面加?表示可为空
var age: String? = &quot;23&quot; 
//抛出空指针异常
val ages = age!!.toInt()
//不做处理返回 null
val ages1 = age?.toInt()
//age为空返回-1
val ages2 = age?.toInt() ?: -1
</code></pre>
</li>
<li>
<p>可以使用 is 运算符检测一个表达式是否某类型的一个实例(类似于Java中的instanceof关键字)。</p>
</li>
</ul>
<h2 id="基本数据类型">基本数据类型</h2>
<ul>
<li>Byte.Short.Int.Long.Float.Double.字符不属于数值类型，是一个独立的数据类型。</li>
<li>使用下划线使数字常量更易读：val oneMillion=1_000_000</li>
<li>三个等号 === 表示比较对象地址，两个 == 表示比较两个值大小</li>
<li>较小类型并不是较大类型的子类型，较小的类型不能隐式转换为较大的类型</li>
<li>数组用Array，还有ByteArray, ShortArray, IntArray,省去了装箱的操作,效率更高</li>
<li>三个引号 &quot;&quot;&quot; 扩起来的字符串，支持多行字符串</li>
<li>String 可以通过 trimMargin() 方法来删除多余的空白。</li>
</ul>
<h2 id="条件控制">条件控制</h2>
<ul>
<li>
<p>可以把 IF 表达式的结果赋值给一个变量</p>
<pre><code class="language-kotlin">val max=if(a&gt;b){
    a
}else{
    b
}
</code></pre>
</li>
<li>
<p>不需要三元操作符<code>val c=if(condition) a else b</code></p>
</li>
<li>
<p>用 in 运算符来检测某个数字是否在指定区间内，区间格式为 x..y ：</p>
</li>
<li>
<p>when 类似其他语言的 switch 操作符</p>
<pre><code class="language-kotlin">when(x){
    1-&gt;print(&quot;x==1&quot;)
    2-&gt;print(&quot;x==2&quot;)
    in 3..10-&gt;print(&quot;x in 3..10&quot;)
    !11-&gt;print(&quot;x not 11&quot;)
    else-&gt;{
        print(&quot;x else&quot;)
    }
}
</code></pre>
</li>
</ul>
<h2 id="循环控制">循环控制</h2>
<ul>
<li>
<p>for (item in collection)  print(item)</p>
<pre><code class="language-kotlin">for(item:Int in ints){
    //...
}
for(i in array.indices){
    //array[i]
}
for((index,value)in array.withIndex()){
    prinln(&quot;the element at $index is $value&quot;)
}
</code></pre>
</li>
<li>
<p>while与do...while</p>
</li>
<li>
<p>在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@</p>
<pre><code class="language-kotlin">loop@ for(i in 1..100){
    for(j in 1..100){
       if(..){
        break@loop
    	}  
    }
}
</code></pre>
</li>
</ul>
<h2 id="类和对象">类和对象</h2>
<ul>
<li>
<p>koltin 中的类可以有一个 主构造器，以及一个或多个次构造器，主构造器是类头部的一部分，位于类名称之后</p>
</li>
<li>
<p>类也可以有二级构造函数，需要加前缀 constructor:</p>
<pre><code class="language-kotlin">class Person constructor(firstName: String) {}

class Person constructor(firstName: String){
    //二级构造函数
    constructor(parent:Person,firstName: String):this(firstName){
        parent.children.add(this)
    }
}
</code></pre>
</li>
<li>
<p>如果一个非抽象类没有声明构造函数(主构造函数或次构造函数)，它会产生一个没有参数的构造函数。构造函数是 public 。如果你不想你的类有公共的构造函数，你就得声明一个空的主构造函数：</p>
<pre><code class="language-kotlin">class DontCreateMe private constructor(){}
</code></pre>
</li>
<li>
<p>如果主构造器没有任何注解，也没有任何可见度修饰符，那么constructor关键字可以省略</p>
</li>
<li>
<p>注意如果主构造函数的所有参数都有默认值，编译器会生成一个附加的无参的构造函数，这个构造函数会直接使用默认值</p>
<pre><code class="language-kotlin">class Customer(val customerName: String = &quot;&quot;)
</code></pre>
</li>
<li>
<p>Kotlin 中类不能有字段。提供了 Backing Fields(后端变量) 机制,备用字段使用field关键字声明,field 关键词只能用于属性的访问器</p>
<pre><code class="language-kotlin">var no:Int=100
		get()=field
		set(value){
            if(value&lt;10){
                field=value
            }else{
                field=-1
            }
		}
</code></pre>
</li>
<li>
<p>构造器中不能包含任何代码，初始化代码可以放在初始化代码段中，初始化代码段使用 init 关键字作为前缀</p>
<pre><code class="language-kotlin">class Person constructor(name:String){
    init{
        println(&quot;name is $name&quot;)
    }
}
</code></pre>
</li>
<li>
<p>内部类使用 inner 关键字来表示,不用inner表示的类里面写的类无法访问外部类的成员</p>
</li>
<li>
<p>类的修饰符classModifier 和_accessModifier_:</p>
<ul>
<li>classModifier</li>
</ul>
<pre><code class="language-kotlin">abstract    // 抽象类  
final       // 类不可继承，默认属性
enum        // 枚举类
open        // 类可继承，类默认是final的
annotation  // 注解类
</code></pre>
<ul>
<li>accessModifier</li>
</ul>
<pre><code class="language-kotlin">private    // 仅在同一个文件中可见
protected  // 同一个文件中或子类可见
public     // 所有调用的地方都可见
internal   // 同一个模块中可见
</code></pre>
</li>
</ul>
<h2 id="继承">继承</h2>
<ul>
<li>
<p>Kotlin 中所有类都继承该 Any 类，它是所有类的超类(Any 不是 java.lang.Object)</p>
<pre><code class="language-kotlin">equals()

hashCode()

toString()
</code></pre>
</li>
<li>
<p>如果一个类要被继承，可以使用 open 关键字进行修饰</p>
</li>
<li>
<p>如果子类有主构造函数， 则基类必须在主构造函数中立即初始化.如果子类没有主构造函数，则必须在每一个二级构造函数中用 super 关键字初始化基类，或者在代理另一个构造函数。初始化基类时，可以调用基类的不同构造方法</p>
<pre><code class="language-kotlin">//没有主构造函数
class Student:Persion{
    constructor(ctx:Context):super(ctx){
        
    }
     constructor(ctx:Context,attr:AttributeSet):super(ctx,attr){
        
    }
}
</code></pre>
</li>
<li>
<p>使用fun声明函数时，此函数默认为final修饰，不能被子类重写。如果允许子类重写该函数，那么就要手动添加 open 修饰</p>
</li>
<li>
<p>属性重写使用 override 关键字，属性必须具有兼容类型，每一个声明的属性都可以通过初始化程序或者getter方法被重写</p>
</li>
<li>
<p>可以用一个var属性重写一个val属性，但是反过来不行。因为val属性本身定义了getter方法，重写为var属性会在衍生类中额外声明一个setter方法</p>
<pre><code class="language-kotlin">interface Foo {
    val count: Int
}

class Bar1(override val count: Int) : Foo

class Bar2 : Foo {
    override var count: Int = 0
}
</code></pre>
</li>
</ul>
<h2 id="接口">接口</h2>
<ul>
<li>
<p>Kotlin 接口与 Java 8 类似，使用 interface 关键字定义接口，允许方法有默认实现：</p>
</li>
<li>
<p>接口中的属性只能是抽象的，不允许初始化值，接口不会保存属性值，实现接口时，必须重写属性</p>
</li>
<li>
<p>实现多个接口时，遇到同一方法继承多个实现的时候</p>
<pre><code class="language-kotlin">interface A {
    fun foo() { print(&quot;A&quot;) }   // 已实现
    fun bar()                  // 未实现，没有方法体，是抽象的
}
 
interface B {
    fun foo() { print(&quot;B&quot;) }   // 已实现
    fun bar() { print(&quot;bar&quot;) } // 已实现
}
class C: A, B{
    override fun foo(){
        super&lt;A&gt;.foo()
        super&lt;B&gt;.foo()
    }
    override fun bar(){
        super&lt;B&gt;.bar()
    }
}
fun main(args: Array&lt;String&gt;) {
    val c =  C()
    c.foo();
    c.bar();
    //ABbar
}
</code></pre>
</li>
</ul>
<h2 id="扩展">扩展</h2>
<ul>
<li>
<p>Kotlin 可以对一个类的属性和方法进行扩展，且不需要继承或使用 Decorator 模式</p>
<p>扩展是一种静态行为，对被扩展的类代码本身不会造成任何影响。</p>
</li>
<li>
<p>扩展函数可以在已有类中添加新的方法</p>
<pre><code class="language-kotlin">fun receiverType.functionName(params){
    body
}
//receiverType：表示函数的接收者，也就是函数扩展的对象
//functionName：扩展函数的名称
//params：扩展函数的参数，可以为NULL
</code></pre>
</li>
<li>
<p>扩展函数是静态解析的，并不是接收者类型的虚拟成员，在调用扩展函数时，具体被调用的的是哪一个函数，由调用函数的的对象表达式来决定的，而不是动态的类型决定的</p>
<pre><code class="language-kotlin">open class C

class D: C()

fun C.foo() = &quot;c&quot;   // 扩展函数 foo

fun D.foo() = &quot;d&quot;   // 扩展函数 foo

fun printFoo(c: C) {
    println(c.foo())  // 类型是 C 类
}

fun main(arg:Array&lt;String&gt;){
    printFoo(D())//输出c
}
</code></pre>
</li>
<li>
<p>若扩展函数和成员函数一致，则使用该函数时，会优先使用成员函数</p>
<pre><code class="language-kotlin">class C {
    fun foo() { println(&quot;成员函数&quot;) }
}

fun C.foo() { println(&quot;扩展函数&quot;) }

fun main(arg:Array&lt;String&gt;){
    var c = C()
    c.foo()//成员函数
}
</code></pre>
</li>
</ul>
<h2 id="数据类与密封类">数据类与密封类</h2>
<ul>
<li>
<p>Kotlin 可以创建一个只包含数据的类，关键字为 data</p>
<pre><code>数据类需要满足以下条件(保证生成代码的一致性以及有意义):

主构造函数至少包含一个参数。
所有的主构造函数的参数必须标识为val 或者 var ;
数据类不可以声明为 abstract, open, sealed 或者 inner;
数据类不能继承其他类 (但是可以实现接口)。
</code></pre>
</li>
<li>
<p>复制使用 copy() 函数，我们可以使用该函数复制对象并修改部分属性</p>
<pre><code class="language-kotlin">data class User(val name: String, val age: Int)
fun main(args: Array&lt;String&gt;) {
    val jack = User(name = &quot;Jack&quot;, age = 1)
    val olderJack = jack.copy(age = 2)
    println(jack)
    println(olderJack)
}
</code></pre>
</li>
<li>
<p>sealed密封类用来表示受限的类继承结构.当一个值为有限几种的类型, 而不能有任何其他类型时.在某种意义上，他们是枚举类的扩展.但每个枚举常量只存在一个实例，而密封类 的一个子类可以有可包含状态的多个实例.密封类可以有子类，但是所有的子类都必须要内嵌在密封类中。</p>
</li>
<li>
<p>sealed 不能修饰 interface ,abstract class(会报 warning,但是不会出现编译错误)</p>
<pre><code class="language-kotlin">sealed class Expr
data class Const(val number: Double) : Expr()
data class Sum(val e1: Expr, val e2: Expr) : Expr()
object NotANumber : Expr()

fun eval(expr: Expr): Double = when(expr) {
    is Expr.Const -&gt; expr.number
    is Expr.Sum -&gt; eval(expr.e1) + eval(expr.e2)
    Expr.NotANumber -&gt; Double.NaN
    // 使用 when 表达式时不再需要 `else` 子句，因为我们已经覆盖了所有的情况
}
</code></pre>
</li>
</ul>
<h2 id="泛型">泛型</h2>
<pre><code class="language-kotlin">class Box&lt;T&gt;(t:T){
    var value=t
}
val box :Box&lt;Int&gt;=Box&lt;Int&gt;(1)
或者
val box =Box(1)
</code></pre>
<ul>
<li>
<p>泛型约束:可以使用泛型约束来设定一个给定参数允许使用的类型</p>
<pre><code class="language-kotlin">fun &lt;T : Comparable&lt;T&gt;&gt; sort(list: List&lt;T&gt;) {
    // ……
}
sort(listOf(1, 2, 3)) // OK。Int 是 Comparable&lt;Int&gt; 的子类型
sort(listOf(HashMap&lt;Int, String&gt;())) // 错误：HashMap&lt;Int, String&gt; 不是 Comparable&lt;HashMap&lt;Int, String&gt;&gt; 的子类型
</code></pre>
</li>
</ul>
<h2 id="枚举类">枚举类</h2>
<pre><code class="language-kotlin">enum class Color{
   RED,BLACK,BLUE,GREEN,WHITE   
}
//枚举初始化
enum class Color(val rgb: Int) {
    RED(0xFF0000),
    GREEN(0x00FF00),
    BLUE(0x0000FF)
}
</code></pre>
<ul>
<li>
<p>使用枚举常量</p>
<pre><code class="language-kotlin">enum class Color{
    RED,BLACK,BLUE,GREEN,WHITE
}

fun main(args: Array&lt;String&gt;) {
    var color:Color=Color.BLUE

    println(Color.values())//以数组的形式，返回枚举值
    println(Color.valueOf(&quot;RED&quot;))//转换指定 name 为枚举值，若未匹配成功，会抛出IllegalArgumentException
    println(color.name)
    println(color.ordinal)
}
</code></pre>
</li>
</ul>
<h2 id="对象表达式声明">对象表达式/声明</h2>
<ul>
<li>
<p>匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的 返回类型或者用作公有属性的类型，那么该函数或属性的实际类型 会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。在匿名对象 中添加的成员将无法访问。</p>
<pre><code class="language-kotlin">class C {
    // 私有函数，所以其返回类型是匿名对象类型
    private fun foo() = object {
        val x: String = &quot;x&quot;
    }

    // 公有函数，所以其返回类型是 Any
    fun publicFoo() = object {
        val x: String = &quot;x&quot;
    }

    fun bar() {
        val x1 = foo().x        // 没问题
        val x2 = publicFoo().x  // 错误：未能解析的引用“x”
    }
}

</code></pre>
</li>
<li>
<p>Kotlin 使用 object 关键字来声明一个对象</p>
</li>
<li>
<p>当对象声明在另一个类的内部时，这个对象并不能通过外部类的实例访问到该对象，而只能通过类名来访问，同样该对象也不能直接访问到外部类的方法和变量</p>
<pre><code class="language-kotlin">lass Site {
    var name = &quot;github&quot;
    object DeskTop{
        var url = &quot;www.github.com&quot;
        fun showName(){
            print{&quot;desk legs $name&quot;} // 错误，不能访问到外部类的方法和变量
        }
    }
}
fun main(args: Array&lt;String&gt;) {
    var site = Site()
    site.DeskTop.url // 错误，不能通过外部类的实例访问到该对象
    Site.DeskTop.url // 正确
}
</code></pre>
</li>
<li>
<p>类内部的对象声明可以用 companion 关键字标记，这样它就与外部类关联在一起，我们就可以直接通过外部类访问到对象的内部元素</p>
<pre><code class="language-kotlin">class MyClass {
    companion object Factory {
        fun create(): MyClass = MyClass()
    }
}
val instance = MyClass.create()   // 访问到对象的内部元素
     		********
//可以省略掉该对象的对象名，然后使用 Companion 替代需要声明的对象名
class MyClass {
    companion object {
    }
}
val x = MyClass.Companion
</code></pre>
</li>
<li>
<p>个类里面只能声明一个内部关联对象，即关键字 companion 只能使用一次</p>
</li>
<li>
<p>对象表达式和对象声明之间的语义差异</p>
<ul>
<li>对象表达式是在使用他们的地方立即执行的</li>
<li>对象声明是在第一次被访问到时延迟初始化的</li>
<li>伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配</li>
</ul>
</li>
</ul>
<h2 id="委托">委托</h2>
<ul>
<li>
<p>有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理</p>
</li>
<li>
<p>类委托. Derived 声明中，by 子句表示，将 b 保存在 Derived 的对象实例内部，而且编译器将会生成继承自 Base 接口的所有方法, 并将调用转发给 b。</p>
<pre><code class="language-kotlin">// 创建接口
interface Base {   
    fun print()
}

// 实现此接口的被委托的类
class BaseImpl(val x: Int) : Base {
    override fun print() { print(x) }
}

// 通过关键字 by 建立委托类
class Derived(b: Base) : Base by b

fun main(args: Array&lt;String&gt;) {
    val b = BaseImpl(10)
    Derived(b).print() // 输出 10
}
</code></pre>
</li>
</ul>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://windherd.github.io//post/baby">
              <h3 class="post-title">
                baby
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'c3a23f028ffa157f67f9',
    clientSecret: 'd9b1f603641c849e309d3273da20035201edbb32',
    repo: 'windherd.github.io',
    owner: 'windherd',
    admin: ['windherd'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/windherd" target="_blank">windherd</a> | 
  <a class="rss" href="https://windherd.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
